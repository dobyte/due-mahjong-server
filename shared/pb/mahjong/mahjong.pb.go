// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mahjong.proto

package mahjong

import (
	common "due-mahjong-server/shared/pb/common"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SeatState int32

const (
	SeatState_None    SeatState = 0
	SeatState_Offline SeatState = 1
	SeatState_Online  SeatState = 2
	SeatState_StandUp SeatState = 3
	SeatState_Ready   SeatState = 4
	SeatState_Unready SeatState = 5
)

var SeatState_name = map[int32]string{
	0: "None",
	1: "Offline",
	2: "Online",
	3: "StandUp",
	4: "Ready",
	5: "Unready",
}

var SeatState_value = map[string]int32{
	"None":    0,
	"Offline": 1,
	"Online":  2,
	"StandUp": 3,
	"Ready":   4,
	"Unready": 5,
}

func (x SeatState) String() string {
	return proto.EnumName(SeatState_name, int32(x))
}

func (SeatState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{0}
}

// 快速开始响应
type QuickStartRes struct {
	Code                 common.Code `protobuf:"varint,1,opt,name=Code,proto3,enum=common.Code" json:"Code,omitempty"`
	GameInfo             *GameInfo   `protobuf:"bytes,2,opt,name=GameInfo,proto3" json:"GameInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *QuickStartRes) Reset()         { *m = QuickStartRes{} }
func (m *QuickStartRes) String() string { return proto.CompactTextString(m) }
func (*QuickStartRes) ProtoMessage()    {}
func (*QuickStartRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{0}
}
func (m *QuickStartRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuickStartRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuickStartRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuickStartRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuickStartRes.Merge(m, src)
}
func (m *QuickStartRes) XXX_Size() int {
	return m.Size()
}
func (m *QuickStartRes) XXX_DiscardUnknown() {
	xxx_messageInfo_QuickStartRes.DiscardUnknown(m)
}

var xxx_messageInfo_QuickStartRes proto.InternalMessageInfo

func (m *QuickStartRes) GetCode() common.Code {
	if m != nil {
		return m.Code
	}
	return common.Code_OK
}

func (m *QuickStartRes) GetGameInfo() *GameInfo {
	if m != nil {
		return m.GameInfo
	}
	return nil
}

// 坐下请求
type SitDownReq struct {
	RoomID               int32    `protobuf:"varint,1,opt,name=RoomID,proto3" json:"RoomID,omitempty"`
	TableID              int32    `protobuf:"varint,2,opt,name=TableID,proto3" json:"TableID,omitempty"`
	SeatID               int32    `protobuf:"varint,3,opt,name=SeatID,proto3" json:"SeatID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SitDownReq) Reset()         { *m = SitDownReq{} }
func (m *SitDownReq) String() string { return proto.CompactTextString(m) }
func (*SitDownReq) ProtoMessage()    {}
func (*SitDownReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{1}
}
func (m *SitDownReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SitDownReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SitDownReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SitDownReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SitDownReq.Merge(m, src)
}
func (m *SitDownReq) XXX_Size() int {
	return m.Size()
}
func (m *SitDownReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SitDownReq.DiscardUnknown(m)
}

var xxx_messageInfo_SitDownReq proto.InternalMessageInfo

func (m *SitDownReq) GetRoomID() int32 {
	if m != nil {
		return m.RoomID
	}
	return 0
}

func (m *SitDownReq) GetTableID() int32 {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *SitDownReq) GetSeatID() int32 {
	if m != nil {
		return m.SeatID
	}
	return 0
}

// 坐下响应
type SitDownRes struct {
	Code                 common.Code `protobuf:"varint,1,opt,name=Code,proto3,enum=common.Code" json:"Code,omitempty"`
	GameInfo             *GameInfo   `protobuf:"bytes,2,opt,name=GameInfo,proto3" json:"GameInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SitDownRes) Reset()         { *m = SitDownRes{} }
func (m *SitDownRes) String() string { return proto.CompactTextString(m) }
func (*SitDownRes) ProtoMessage()    {}
func (*SitDownRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{2}
}
func (m *SitDownRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SitDownRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SitDownRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SitDownRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SitDownRes.Merge(m, src)
}
func (m *SitDownRes) XXX_Size() int {
	return m.Size()
}
func (m *SitDownRes) XXX_DiscardUnknown() {
	xxx_messageInfo_SitDownRes.DiscardUnknown(m)
}

var xxx_messageInfo_SitDownRes proto.InternalMessageInfo

func (m *SitDownRes) GetCode() common.Code {
	if m != nil {
		return m.Code
	}
	return common.Code_OK
}

func (m *SitDownRes) GetGameInfo() *GameInfo {
	if m != nil {
		return m.GameInfo
	}
	return nil
}

// 站起响应
type StandUpRes struct {
	Code                 common.Code `protobuf:"varint,1,opt,name=Code,proto3,enum=common.Code" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *StandUpRes) Reset()         { *m = StandUpRes{} }
func (m *StandUpRes) String() string { return proto.CompactTextString(m) }
func (*StandUpRes) ProtoMessage()    {}
func (*StandUpRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{3}
}
func (m *StandUpRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StandUpRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StandUpRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StandUpRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StandUpRes.Merge(m, src)
}
func (m *StandUpRes) XXX_Size() int {
	return m.Size()
}
func (m *StandUpRes) XXX_DiscardUnknown() {
	xxx_messageInfo_StandUpRes.DiscardUnknown(m)
}

var xxx_messageInfo_StandUpRes proto.InternalMessageInfo

func (m *StandUpRes) GetCode() common.Code {
	if m != nil {
		return m.Code
	}
	return common.Code_OK
}

// 开始准备响应
type ReadyRes struct {
	Code                 common.Code `protobuf:"varint,1,opt,name=Code,proto3,enum=common.Code" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ReadyRes) Reset()         { *m = ReadyRes{} }
func (m *ReadyRes) String() string { return proto.CompactTextString(m) }
func (*ReadyRes) ProtoMessage()    {}
func (*ReadyRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{4}
}
func (m *ReadyRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadyRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadyRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadyRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadyRes.Merge(m, src)
}
func (m *ReadyRes) XXX_Size() int {
	return m.Size()
}
func (m *ReadyRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadyRes.DiscardUnknown(m)
}

var xxx_messageInfo_ReadyRes proto.InternalMessageInfo

func (m *ReadyRes) GetCode() common.Code {
	if m != nil {
		return m.Code
	}
	return common.Code_OK
}

// 取消准备响应
type UnreadyRes struct {
	Code                 common.Code `protobuf:"varint,1,opt,name=Code,proto3,enum=common.Code" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UnreadyRes) Reset()         { *m = UnreadyRes{} }
func (m *UnreadyRes) String() string { return proto.CompactTextString(m) }
func (*UnreadyRes) ProtoMessage()    {}
func (*UnreadyRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{5}
}
func (m *UnreadyRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadyRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadyRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadyRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadyRes.Merge(m, src)
}
func (m *UnreadyRes) XXX_Size() int {
	return m.Size()
}
func (m *UnreadyRes) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadyRes.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadyRes proto.InternalMessageInfo

func (m *UnreadyRes) GetCode() common.Code {
	if m != nil {
		return m.Code
	}
	return common.Code_OK
}

// 游戏信息
type GameInfo struct {
	Room                 *Room    `protobuf:"bytes,1,opt,name=Room,proto3" json:"Room,omitempty"`
	Table                *Table   `protobuf:"bytes,2,opt,name=Table,proto3" json:"Table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameInfo) Reset()         { *m = GameInfo{} }
func (m *GameInfo) String() string { return proto.CompactTextString(m) }
func (*GameInfo) ProtoMessage()    {}
func (*GameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{6}
}
func (m *GameInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInfo.Merge(m, src)
}
func (m *GameInfo) XXX_Size() int {
	return m.Size()
}
func (m *GameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GameInfo proto.InternalMessageInfo

func (m *GameInfo) GetRoom() *Room {
	if m != nil {
		return m.Room
	}
	return nil
}

func (m *GameInfo) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

type FetchRoomsReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchRoomsReq) Reset()         { *m = FetchRoomsReq{} }
func (m *FetchRoomsReq) String() string { return proto.CompactTextString(m) }
func (*FetchRoomsReq) ProtoMessage()    {}
func (*FetchRoomsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{7}
}
func (m *FetchRoomsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchRoomsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchRoomsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchRoomsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchRoomsReq.Merge(m, src)
}
func (m *FetchRoomsReq) XXX_Size() int {
	return m.Size()
}
func (m *FetchRoomsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchRoomsReq.DiscardUnknown(m)
}

var xxx_messageInfo_FetchRoomsReq proto.InternalMessageInfo

type Room struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	MinEntryLimit        int32    `protobuf:"varint,3,opt,name=MinEntryLimit,proto3" json:"MinEntryLimit,omitempty"`
	MaxEntryLimit        int32    `protobuf:"varint,4,opt,name=MaxEntryLimit,proto3" json:"MaxEntryLimit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Room) Reset()         { *m = Room{} }
func (m *Room) String() string { return proto.CompactTextString(m) }
func (*Room) ProtoMessage()    {}
func (*Room) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{8}
}
func (m *Room) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Room) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Room.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Room) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Room.Merge(m, src)
}
func (m *Room) XXX_Size() int {
	return m.Size()
}
func (m *Room) XXX_DiscardUnknown() {
	xxx_messageInfo_Room.DiscardUnknown(m)
}

var xxx_messageInfo_Room proto.InternalMessageInfo

func (m *Room) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Room) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Room) GetMinEntryLimit() int32 {
	if m != nil {
		return m.MinEntryLimit
	}
	return 0
}

func (m *Room) GetMaxEntryLimit() int32 {
	if m != nil {
		return m.MaxEntryLimit
	}
	return 0
}

type Table struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Seats                []*Seat  `protobuf:"bytes,2,rep,name=Seats,proto3" json:"Seats,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{9}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Table.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

func (m *Table) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Table) GetSeats() []*Seat {
	if m != nil {
		return m.Seats
	}
	return nil
}

type Seat struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Player               *Player  `protobuf:"bytes,2,opt,name=Player,proto3" json:"Player,omitempty"`
	IsOnline             bool     `protobuf:"varint,3,opt,name=IsOnline,proto3" json:"IsOnline,omitempty"`
	IsReady              bool     `protobuf:"varint,4,opt,name=IsReady,proto3" json:"IsReady,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Seat) Reset()         { *m = Seat{} }
func (m *Seat) String() string { return proto.CompactTextString(m) }
func (*Seat) ProtoMessage()    {}
func (*Seat) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{10}
}
func (m *Seat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Seat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Seat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Seat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Seat.Merge(m, src)
}
func (m *Seat) XXX_Size() int {
	return m.Size()
}
func (m *Seat) XXX_DiscardUnknown() {
	xxx_messageInfo_Seat.DiscardUnknown(m)
}

var xxx_messageInfo_Seat proto.InternalMessageInfo

func (m *Seat) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Seat) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *Seat) GetIsOnline() bool {
	if m != nil {
		return m.IsOnline
	}
	return false
}

func (m *Seat) GetIsReady() bool {
	if m != nil {
		return m.IsReady
	}
	return false
}

type Player struct {
	User                 *common.User `protobuf:"bytes,1,opt,name=User,proto3" json:"User,omitempty"`
	IsMyself             bool         `protobuf:"varint,2,opt,name=IsMyself,proto3" json:"IsMyself,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{11}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetUser() *common.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Player) GetIsMyself() bool {
	if m != nil {
		return m.IsMyself
	}
	return false
}

// 玩家座位状态变更通知
type SeatStateChangeNotify struct {
	SeatID               int32     `protobuf:"varint,1,opt,name=SeatID,proto3" json:"SeatID,omitempty"`
	SeatState            SeatState `protobuf:"varint,2,opt,name=SeatState,proto3,enum=mahjong.SeatState" json:"SeatState,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SeatStateChangeNotify) Reset()         { *m = SeatStateChangeNotify{} }
func (m *SeatStateChangeNotify) String() string { return proto.CompactTextString(m) }
func (*SeatStateChangeNotify) ProtoMessage()    {}
func (*SeatStateChangeNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{12}
}
func (m *SeatStateChangeNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeatStateChangeNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeatStateChangeNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeatStateChangeNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeatStateChangeNotify.Merge(m, src)
}
func (m *SeatStateChangeNotify) XXX_Size() int {
	return m.Size()
}
func (m *SeatStateChangeNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_SeatStateChangeNotify.DiscardUnknown(m)
}

var xxx_messageInfo_SeatStateChangeNotify proto.InternalMessageInfo

func (m *SeatStateChangeNotify) GetSeatID() int32 {
	if m != nil {
		return m.SeatID
	}
	return 0
}

func (m *SeatStateChangeNotify) GetSeatState() SeatState {
	if m != nil {
		return m.SeatState
	}
	return SeatState_None
}

// 玩家入座通知
type TakeSeatNotify struct {
	Seat                 *Seat    `protobuf:"bytes,1,opt,name=Seat,proto3" json:"Seat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TakeSeatNotify) Reset()         { *m = TakeSeatNotify{} }
func (m *TakeSeatNotify) String() string { return proto.CompactTextString(m) }
func (*TakeSeatNotify) ProtoMessage()    {}
func (*TakeSeatNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{13}
}
func (m *TakeSeatNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TakeSeatNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TakeSeatNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TakeSeatNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TakeSeatNotify.Merge(m, src)
}
func (m *TakeSeatNotify) XXX_Size() int {
	return m.Size()
}
func (m *TakeSeatNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_TakeSeatNotify.DiscardUnknown(m)
}

var xxx_messageInfo_TakeSeatNotify proto.InternalMessageInfo

func (m *TakeSeatNotify) GetSeat() *Seat {
	if m != nil {
		return m.Seat
	}
	return nil
}

// 游戏信息通知
type GameInfoNotify struct {
	GameInfo             *GameInfo `protobuf:"bytes,1,opt,name=GameInfo,proto3" json:"GameInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GameInfoNotify) Reset()         { *m = GameInfoNotify{} }
func (m *GameInfoNotify) String() string { return proto.CompactTextString(m) }
func (*GameInfoNotify) ProtoMessage()    {}
func (*GameInfoNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_d34f912f3b7761cf, []int{14}
}
func (m *GameInfoNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInfoNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInfoNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameInfoNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInfoNotify.Merge(m, src)
}
func (m *GameInfoNotify) XXX_Size() int {
	return m.Size()
}
func (m *GameInfoNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInfoNotify.DiscardUnknown(m)
}

var xxx_messageInfo_GameInfoNotify proto.InternalMessageInfo

func (m *GameInfoNotify) GetGameInfo() *GameInfo {
	if m != nil {
		return m.GameInfo
	}
	return nil
}

func init() {
	proto.RegisterEnum("mahjong.SeatState", SeatState_name, SeatState_value)
	proto.RegisterType((*QuickStartRes)(nil), "mahjong.QuickStartRes")
	proto.RegisterType((*SitDownReq)(nil), "mahjong.SitDownReq")
	proto.RegisterType((*SitDownRes)(nil), "mahjong.SitDownRes")
	proto.RegisterType((*StandUpRes)(nil), "mahjong.StandUpRes")
	proto.RegisterType((*ReadyRes)(nil), "mahjong.ReadyRes")
	proto.RegisterType((*UnreadyRes)(nil), "mahjong.UnreadyRes")
	proto.RegisterType((*GameInfo)(nil), "mahjong.GameInfo")
	proto.RegisterType((*FetchRoomsReq)(nil), "mahjong.FetchRoomsReq")
	proto.RegisterType((*Room)(nil), "mahjong.Room")
	proto.RegisterType((*Table)(nil), "mahjong.Table")
	proto.RegisterType((*Seat)(nil), "mahjong.Seat")
	proto.RegisterType((*Player)(nil), "mahjong.Player")
	proto.RegisterType((*SeatStateChangeNotify)(nil), "mahjong.SeatStateChangeNotify")
	proto.RegisterType((*TakeSeatNotify)(nil), "mahjong.TakeSeatNotify")
	proto.RegisterType((*GameInfoNotify)(nil), "mahjong.GameInfoNotify")
}

func init() { proto.RegisterFile("mahjong.proto", fileDescriptor_d34f912f3b7761cf) }

var fileDescriptor_d34f912f3b7761cf = []byte{
	// 601 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0x53, 0x3b, 0x75, 0xa7, 0x8d, 0x6b, 0x56, 0x02, 0x45, 0x3d, 0x44, 0xe9, 0x52, 0x89,
	0x0a, 0xd1, 0x14, 0xa5, 0x12, 0x27, 0x24, 0x24, 0x1a, 0x8a, 0x2c, 0xd1, 0x16, 0xd6, 0x2d, 0x07,
	0x24, 0x24, 0xb6, 0xf1, 0xa6, 0x31, 0x8d, 0x77, 0x5b, 0x7b, 0x5b, 0xc8, 0x9b, 0xf0, 0x48, 0x1c,
	0x79, 0x04, 0x54, 0x5e, 0x04, 0xed, 0x8f, 0x5d, 0x47, 0x39, 0x90, 0x0b, 0x37, 0xcf, 0xf7, 0x7d,
	0x33, 0x3b, 0xfb, 0xcd, 0xac, 0xa1, 0x95, 0xd1, 0xf1, 0x57, 0xc1, 0x2f, 0x7a, 0x57, 0xb9, 0x90,
	0x02, 0xad, 0xd8, 0x70, 0x13, 0x86, 0x22, 0x61, 0x06, 0xdc, 0x5c, 0x1f, 0x8a, 0x2c, 0x13, 0xdc,
	0x44, 0xf8, 0x0b, 0xb4, 0x3e, 0xdc, 0xa4, 0xc3, 0xcb, 0x58, 0xd2, 0x5c, 0x12, 0x56, 0xa0, 0x2e,
	0xb8, 0x07, 0x22, 0x61, 0x6d, 0xa7, 0xeb, 0xec, 0x04, 0xfd, 0xf5, 0x9e, 0x55, 0x2b, 0x8c, 0x68,
	0x06, 0xed, 0x82, 0xff, 0x96, 0x66, 0x2c, 0xe2, 0x23, 0xd1, 0x6e, 0x74, 0x9d, 0x9d, 0xb5, 0xfe,
	0x83, 0x5e, 0x79, 0x6e, 0x49, 0x90, 0x4a, 0x82, 0x3f, 0x02, 0xc4, 0xa9, 0x1c, 0x88, 0x6f, 0x9c,
	0xb0, 0x6b, 0xf4, 0x08, 0x9a, 0x44, 0x88, 0x2c, 0x1a, 0xe8, 0x03, 0x3c, 0x62, 0x23, 0xd4, 0x86,
	0x95, 0x53, 0x7a, 0x3e, 0x61, 0xd1, 0x40, 0xd7, 0xf4, 0x48, 0x19, 0xaa, 0x8c, 0x98, 0x51, 0x19,
	0x0d, 0xda, 0xcb, 0x26, 0xc3, 0x44, 0xf8, 0x73, 0xad, 0xee, 0x7f, 0x68, 0xbb, 0x07, 0x10, 0x4b,
	0xca, 0x93, 0xb3, 0xab, 0x85, 0xca, 0xe3, 0x67, 0xe0, 0x13, 0x46, 0x93, 0xe9, 0x62, 0xea, 0x1e,
	0xc0, 0x19, 0xcf, 0x17, 0xd7, 0xc7, 0xf7, 0xcd, 0xa3, 0x2d, 0x70, 0x95, 0x69, 0x5a, 0xbd, 0xd6,
	0x6f, 0x55, 0x97, 0x50, 0x20, 0xd1, 0x14, 0xda, 0x06, 0x4f, 0xdb, 0x67, 0x2f, 0x1a, 0x54, 0x1a,
	0x8d, 0x12, 0x43, 0xe2, 0x0d, 0x68, 0x1d, 0x32, 0x39, 0x1c, 0xab, 0x94, 0x82, 0xb0, 0x6b, 0x7c,
	0x6b, 0x2a, 0xa3, 0x00, 0x1a, 0xd5, 0x80, 0x1a, 0xd1, 0x00, 0x21, 0x70, 0x8f, 0x69, 0x66, 0xaa,
	0xad, 0x12, 0xfd, 0x8d, 0xb6, 0xa1, 0x75, 0x94, 0xf2, 0x37, 0x5c, 0xe6, 0xd3, 0x77, 0x69, 0x96,
	0x4a, 0x3b, 0x9d, 0x59, 0x50, 0xab, 0xe8, 0xf7, 0x9a, 0xca, 0xb5, 0xaa, 0x3a, 0x88, 0x5f, 0xda,
	0x76, 0xe7, 0x0e, 0x7e, 0x0c, 0x9e, 0x9a, 0x76, 0xd1, 0x6e, 0x74, 0x97, 0x67, 0xee, 0xaa, 0x50,
	0x62, 0x38, 0x7c, 0x03, 0xae, 0xfa, 0x98, 0x4b, 0x7e, 0x02, 0xcd, 0xf7, 0x13, 0x3a, 0x65, 0xb9,
	0x75, 0x61, 0xa3, 0xca, 0x36, 0x30, 0xb1, 0x34, 0xda, 0x04, 0x3f, 0x2a, 0x4e, 0xf8, 0x24, 0xe5,
	0x4c, 0xdf, 0xc2, 0x27, 0x55, 0xac, 0xf6, 0x32, 0x2a, 0xf4, 0x60, 0x75, 0xeb, 0x3e, 0x29, 0x43,
	0x7c, 0x58, 0x96, 0x57, 0xe3, 0x3b, 0x2b, 0x58, 0x6e, 0x07, 0x52, 0x8d, 0x4f, 0x61, 0x44, 0x33,
	0xe6, 0x84, 0xa3, 0x69, 0xc1, 0x26, 0x23, 0xdd, 0x8c, 0x3e, 0xc1, 0xc4, 0x98, 0xc2, 0x43, 0xd5,
	0x7e, 0x2c, 0xa9, 0x64, 0x07, 0x63, 0xca, 0x2f, 0xd8, 0xb1, 0x90, 0xe9, 0x68, 0x5a, 0x5b, 0x7c,
	0xa7, 0xbe, 0xf8, 0xe8, 0x39, 0xac, 0x56, 0x09, 0xba, 0x5a, 0xd0, 0x47, 0x33, 0xc6, 0x68, 0x86,
	0xdc, 0x8b, 0xf0, 0x3e, 0x04, 0xa7, 0xf4, 0x92, 0x29, 0xc0, 0xd6, 0xde, 0x32, 0x9e, 0xcd, 0xed,
	0x90, 0xf6, 0x55, 0x53, 0xf8, 0x15, 0x04, 0xe5, 0xca, 0xd9, 0xa4, 0xfa, 0x0b, 0x72, 0xfe, 0xf9,
	0x82, 0x9e, 0xc6, 0xb5, 0x3e, 0x91, 0x0f, 0xee, 0xb1, 0xe0, 0x2c, 0x5c, 0x42, 0x6b, 0xb0, 0x72,
	0x32, 0x1a, 0x29, 0x73, 0x43, 0x07, 0x01, 0x34, 0x8d, 0xd1, 0x61, 0x43, 0x11, 0xf6, 0xc5, 0x85,
	0xcb, 0x68, 0x15, 0x3c, 0x6d, 0x73, 0xe8, 0x2a, 0xdc, 0xbe, 0x95, 0xd0, 0x7b, 0xfd, 0xe2, 0xe7,
	0x5d, 0xc7, 0xf9, 0x75, 0xd7, 0x71, 0x7e, 0xdf, 0x75, 0x9c, 0x1f, 0x7f, 0x3a, 0x4b, 0x9f, 0xb6,
	0x93, 0x1b, 0xb6, 0x6b, 0xdb, 0xd8, 0x2d, 0x58, 0x7e, 0xcb, 0xf2, 0xbd, 0x62, 0x4c, 0x73, 0x96,
	0xec, 0x5d, 0x9d, 0xef, 0x59, 0xe2, 0xbc, 0xa9, 0x7f, 0x77, 0xfb, 0x7f, 0x03, 0x00, 0x00, 0xff,
	0xff, 0x35, 0xc2, 0xc2, 0x8b, 0x22, 0x05, 0x00, 0x00,
}

func (m *QuickStartRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuickStartRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuickStartRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameInfo != nil {
		{
			size, err := m.GameInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SitDownReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SitDownReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SitDownReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeatID != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.SeatID))
		i--
		dAtA[i] = 0x18
	}
	if m.TableID != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomID != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.RoomID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SitDownRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SitDownRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SitDownRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameInfo != nil {
		{
			size, err := m.GameInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StandUpRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StandUpRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StandUpRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadyRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadyRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadyRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnreadyRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadyRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadyRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Table != nil {
		{
			size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Room != nil {
		{
			size, err := m.Room.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchRoomsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRoomsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchRoomsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Room) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Room) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Room) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxEntryLimit != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.MaxEntryLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.MinEntryLimit != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.MinEntryLimit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMahjong(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Seats) > 0 {
		for iNdEx := len(m.Seats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Seats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMahjong(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ID != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Seat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Seat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Seat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsReady {
		i--
		if m.IsReady {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsOnline {
		i--
		if m.IsOnline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Player) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsMyself {
		i--
		if m.IsMyself {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeatStateChangeNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeatStateChangeNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeatStateChangeNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeatState != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.SeatState))
		i--
		dAtA[i] = 0x10
	}
	if m.SeatID != 0 {
		i = encodeVarintMahjong(dAtA, i, uint64(m.SeatID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TakeSeatNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TakeSeatNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TakeSeatNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seat != nil {
		{
			size, err := m.Seat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GameInfoNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInfoNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameInfoNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameInfo != nil {
		{
			size, err := m.GameInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMahjong(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMahjong(dAtA []byte, offset int, v uint64) int {
	offset -= sovMahjong(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QuickStartRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMahjong(uint64(m.Code))
	}
	if m.GameInfo != nil {
		l = m.GameInfo.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SitDownReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomID != 0 {
		n += 1 + sovMahjong(uint64(m.RoomID))
	}
	if m.TableID != 0 {
		n += 1 + sovMahjong(uint64(m.TableID))
	}
	if m.SeatID != 0 {
		n += 1 + sovMahjong(uint64(m.SeatID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SitDownRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMahjong(uint64(m.Code))
	}
	if m.GameInfo != nil {
		l = m.GameInfo.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StandUpRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMahjong(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadyRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMahjong(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadyRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMahjong(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Room != nil {
		l = m.Room.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchRoomsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Room) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMahjong(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.MinEntryLimit != 0 {
		n += 1 + sovMahjong(uint64(m.MinEntryLimit))
	}
	if m.MaxEntryLimit != 0 {
		n += 1 + sovMahjong(uint64(m.MaxEntryLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMahjong(uint64(m.ID))
	}
	if len(m.Seats) > 0 {
		for _, e := range m.Seats {
			l = e.Size()
			n += 1 + l + sovMahjong(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Seat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMahjong(uint64(m.ID))
	}
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.IsOnline {
		n += 2
	}
	if m.IsReady {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.IsMyself {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SeatStateChangeNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeatID != 0 {
		n += 1 + sovMahjong(uint64(m.SeatID))
	}
	if m.SeatState != 0 {
		n += 1 + sovMahjong(uint64(m.SeatState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TakeSeatNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seat != nil {
		l = m.Seat.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameInfoNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameInfo != nil {
		l = m.GameInfo.Size()
		n += 1 + l + sovMahjong(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMahjong(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMahjong(x uint64) (n int) {
	return sovMahjong(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QuickStartRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuickStartRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuickStartRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= common.Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameInfo == nil {
				m.GameInfo = &GameInfo{}
			}
			if err := m.GameInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SitDownReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SitDownReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SitDownReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			m.RoomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatID", wireType)
			}
			m.SeatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SitDownRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SitDownRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SitDownRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= common.Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameInfo == nil {
				m.GameInfo = &GameInfo{}
			}
			if err := m.GameInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StandUpRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StandUpRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StandUpRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= common.Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadyRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadyRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadyRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= common.Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadyRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadyRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadyRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= common.Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Room == nil {
				m.Room = &Room{}
			}
			if err := m.Room.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRoomsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchRoomsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchRoomsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Room) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Room: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Room: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEntryLimit", wireType)
			}
			m.MinEntryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinEntryLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntryLimit", wireType)
			}
			m.MaxEntryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEntryLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seats = append(m.Seats, &Seat{})
			if err := m.Seats[len(m.Seats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Seat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Seat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Seat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReady = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &common.User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMyself", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMyself = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeatStateChangeNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeatStateChangeNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeatStateChangeNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatID", wireType)
			}
			m.SeatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatState", wireType)
			}
			m.SeatState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatState |= SeatState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TakeSeatNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TakeSeatNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TakeSeatNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seat == nil {
				m.Seat = &Seat{}
			}
			if err := m.Seat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInfoNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInfoNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInfoNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMahjong
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMahjong
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameInfo == nil {
				m.GameInfo = &GameInfo{}
			}
			if err := m.GameInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMahjong(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMahjong
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMahjong(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMahjong
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMahjong
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMahjong
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMahjong
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMahjong
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMahjong        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMahjong          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMahjong = fmt.Errorf("proto: unexpected end of group")
)
